# 第五章继承

### 目录

1. [super和this的区别](#t1)

2. [子类能从父类中继承到私有属性吗](#t2)

3. [父类构造器](#t3)

4. [实例化子类时会同时实例化一个父类吗](#t4)

5. [调用子类构造器时会调用父类构造方法](#t5)

6. [多态的概念](#t6)

7. [方法签名](#t7)

8. [问题：能覆盖一个private或static方法吗](#t8)

9. [方法的覆盖](#t9)

10. [阻止继承和覆盖](#t10)

11. [强制转换](#t11)

12. [instanceof](#t12)

13. [问题 多态调用子类继承方法，方法中含有子类特有的方法](#t13)

    <hr>

* <span id="t1">super 和 this 的区别</span>

  > this
  >
  > ​	this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
  >
  > super 
  >
  > ​	和 this 引用不同，super 不是一个对象的引用，不能将super赋给一个对象变量
  >
  > 它只是一个指示编译器调用超类方法的特殊关键字

* <span id="t2">子类能从父类中继承到私有属性吗</span>

  > 官方文档解释：
  >
  > ​	A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass
  >
  > ​	子类不继承其父类的私有成员。但是，如果超类有访问其私有字段的公共或受保护方法，子类也可以使用这些方法

* <span id="t3">父类构造器</span>

  > 有时子类并不能直接访问父类的私有属性，可以通过调用父类构造器来初始化父类私有属性但是`super()`语句即super调用构造器的语句必须是子类构造器的第一条语句

* <span id="t4">实例化子类时会同时实例化一个父类吗</span>

  > 在实例化子类时并不会实例化一个父类，但是会调用父类的构造方法可以初始化父类的属性

* <span id="t5">调用子类构造器时会调用父类构造方法</span>

  > 如果子类构造器没有显示的调用父类构造器，则自动调用父类默认（无参）构造器如果父类没有无参构造器编译器就会报错

* <span id="t6">多态的概念</span>

  > 一个引用变量可以指示多种事件类型的现象称为多态

* <span id="t7">方法签名</span>

  > 方法的名字和参数列表称为方法的签名 

* <span id="t8">问题：能覆盖一个private或static的方法吗</span>

  > 不能覆盖一个private，static的方法，如果在子类中写了一个名字相同结果与在子类中增加一个方法是一样的，当用父类引用调用子类对象这个方法时调用的还是父类的方法。
  >
  > static 方法之所以不能被覆盖原因是：方法覆盖是基于运行时动态绑定的但static方法是编译时静态绑定的，static和类的任何实例都不相关，所以概念上不适用

* <span id="t9">方法的覆盖</span>

  * 定义

    > 在子类中定义了一个与超类签名相同的方法，子类中的方法将覆盖超类中的方法

  * 覆盖规则

    > **注意**：返回类型不是签名的一部分，因此，在覆盖方法时一定要注意返回类型的兼容性

    1. 父类中的方法在子类中必须可见，即子类继承了父类中的该方法（可以显式的使用super关键字来访问父类中的被重写的方法）
    2. 如果父类中的方法为private类型的，那么子类则无法继承，也无法覆盖
    3. 如果父类和子类都是static方法，那么子类隐藏父类的方法，而不是重写父类方法
    4. 子类和父类的方法必须要具有相同的函数名称、参数列表，并且子类的返回值与父类相同或者是父类返回类型的子类型（jdk1.5之后）
    5. 如果方法名称相同而参数列表不同（返回类型可以相同也可以不同），那么只是方法的重载，而非重写。
    6. 如果方法名称和参数列表相同，返回值类型不同，子类返回值类型也不是父类返回值类型的子类，编译器就会报错。（无法覆盖）
    7. 子类方法的访问权限不能小于父类方法的访问权限（可以具有相同的访问权限或者子类的访问权限大于父类） 
    8. 子类方法不能比父类方法抛出更多的编译时异常（不是运行时异常），即子类方法抛出的编译时异常或者和父类相同或者是父类异常的子类。

* <span id="t10">阻止继承和覆盖</span>

  > 可以使用`final`关键字修饰类防止类的继承
  >
  > 可以使用`final`关键字修饰方法防止方法的覆盖

* <span id="t11">强制转换</span>（引用）

  > 一个子类可以转换成父类但是如果一个父类要转换成子类必须的经过强制转换，
  >
  > **强制转换有前提**：前提是要转换成子类的**父类引用必须得指向一个子类对象**否则会报错

* <span id="t12">instanceof</span>

  > instanceof 运算符 用法：
  >
  > ​	a(引用) instanceof X(类) 
  >
  > 返回的是true或false
  >
  > 判断a引用所**指向的对象**是否是X类的一个实例
  >
  > 可以在强制转换的时候使用避免出错

* <span id="t13">问题 多态调用子类继承方法，方法中含有子类特有的方法</span>

  > 问题：使用多态调用子类继承的方法其中这个方法调用的子类特有的方法可以吗?
  >
  > 答案：是可以的